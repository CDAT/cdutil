# Adapted for numpy/ma/cdms2 by convertcdms.py
import numpy
import numpy.ma
import MV2
import cdms2
import regrid2
import cdtime
from . import ValidationFunctions
import genutil


class WeightsMakerError(Exception):
    def __init__(self, args):
        self.args = args


class WeightsMaker(object):
    """
    The WeightsMaker generates a transient variable containing fractions (between 0 and 1), with the value 0 identifying
    which cells should be excluded from consideration (i.e., masked out). In calculating the mean value of a variable,
    these fractions are typically used to "weight" grid cells
    (in addition to possibly weighting by the area of the grid cell).  In the simplest case, only 0's and 1's will be
    generated, indicating which cells will be masked or not.
    """

    __slots__ = [
        'mask',
        'values',
        'actions',
        'file',
        'combiningActions',
        'data',
        '_var']

    def __init__(self, source=None, var=None, values=None, actions=[
                 MV2.equal, ], combiningActions=[MV2.multiply, ]):
        """
        :param source: either a file name or a transient variable.
        :type source: str

        :param var: the name of the variable that is needed from the file specified in the "source" argument
                (except when "source" is a transient variable, in which case this argument is ignored).
        :type var: str

        :param values: a list (with the same number of elements as the "actions" list) containing the values that will
                be passed to each function contained in the "actions" list. If "values" is defined as a list or tuple
                whose first element is 'input', then the variable passed to action is not the one referred to by
                "source" but the one sent to the "get" function (i.e. when the function is executed).
        :type values: list

        :param actions: a list (or a tuple) of functions that will be used by the WeightsMaker to create the weights.
                Each of these functions must accept two arguments: the first argument is an array
                (of the same shape as the mask), and the second is a scalar or a tuple.
                For example, "actions=MV.equal" will generate weights with 1's assigned to cells where elements of the
                array equal to the scalar specified in values (see below) and 0's assigned to all other cells.
                By default the array passed to the function is the one defined by "source," but an alternative "source"
                can be passed at the time of the mask creation (see the "get" and "values" explanations below).
                The default action (if "actions" is set to None) is: MV.equal.
        :type actions: list or tuple

        :param combiningActions: a list (with one element less than the number of elements in the "actions" list)
                containing functions used to combine the actions of the functions specified in the "actions" list.
                There is no need to define combiningActions when there is only one "action" defined.
                The first "combining-action" will be used to produce a new temporary mask representing the result of
                combining the first and second masks generated by the functions specified in the "actions" list.
                This result will be used subsequently with the result of action 3 and the second  "combiningAction",
                and so on. The default logical action is MV.multiply.
        :type combiningActions: list

        .. note::

            When calling the get function of the WeightsMaker object, the variable being processed may be passed,
            allowing a mask to be generated based on the data itself.  (If, for example, the WeightsMaker is passed
            values=["input", 273.15] and actions=[MV.less], temperatures below freezing would be masked.)
        """
        if isinstance(source, bytes):
            self.file = source
            self.mask = None
        else:
            self.mask = source
            self.file = None
        self.variable = var
        self.values = values
        self.actions = actions
        self.combiningActions = combiningActions

    def get(self, input=None):
        v = self.mask
        if isinstance(self.file, bytes):
            f = cdms2.open(self.file)
            v = f(self.variable, squeeze=1)
            f.close()
# if v is None: return v
        if self.values is None:
            return v
        else:
            # if v is not None:
            # m=MV2.zeros(v.shape)
            # m.setAxisList(v.getAxisList())
            # else:
            # if it is still None that means we didn't define a mask slab
            # probably all coming from input
            # m=MV2.zeros(input.shape)
            # m.setAxisList(input.getAxisList())
            for iv in range(len(self.values)):
                val = self.values[iv]
                comp = v
                if type(val) in [list, tuple]:
                    if val[0] == 'input':
                        val = val[1]
                        comp = input
                m2 = self.actions[iv](comp, val)
                if iv == 0:
                    m = m2
                else:
                    m = self.combiningActions[iv - 1](m, m2)
            return m

    __call__ = get

    # Representation of Mask object
    def __str__(self):
        s = 'WeightsMaker Object: '
        if self.file is None and (
                (self.mask is None) or (self.mask is MV2.nomask)):
            s += 'None'
        else:
            if self.file is not None:
                s += '\nfile:' + str(self.file) + '\nVar:' + str(self.variable)
            if not ((self.mask is None) or (self.mask is MV2.nomask)):
                s += '\nmask:' + str(self.mask)
            if self.values is not None:
                s += '\nvalues: ['
                for v in self.values:
                    s += str(v) + ', '
                s += ']\nactions: ['
                for a in self.actions:
                    s += str(a) + ', '
                s += ']\ncombiningActions: ['
                for c in self.combiningActions:
                    s += str(c)
                s += ']\n'
        return s

    def _set_var(self, value):
        self._var = ValidationFunctions.checkStringOrNone(self, 'var', value)

    def _get_var(self):
        return self._var

    def _del_var(self):
        del self._var
    variable = property(_get_var, _set_var)


class WeightedGridMakerError(WeightsMakerError):
    pass


class GridAxis(object):

    __slots__ = ['_first', '_n', '_delta', '_type', ]

    def __init__(self):
        self.first = None
        self.n = None
        self.delta = None
        self.type = 'Uniform'

    def __str__(self):
        s = 'first:' + str(self.first) + '\n'
        s += 'n:' + str(self.n) + '\n'
        s += 'delta:' + str(self.delta) + '\n'
        s += 'type:' + str(self.type)
        return s

    def _set_first(self, value):
        self._first = ValidationFunctions.checkNumberOrNone(
            self, 'first', value)

    def _get_first(self):
        return self._first
    first = property(_get_first, _set_first)

    def _set_delta(self, value):
        self._delta = ValidationFunctions.checkNumberOrNone(
            self, 'delta', value)

    def _get_delta(self):
        return self._delta
    delta = property(_get_delta, _set_delta)

    def _set_n(self, value):
        self._n = ValidationFunctions.checkIntOrNone(self, 'n', value)

    def _get_n(self):
        return self._n
    n = property(_get_n, _set_n)

    def _set_type(self, value):
        self._type = ValidationFunctions.checkAxisType(self, 'type', value)

    def _get_type(self):
        return self._type
    type = property(_get_type, _set_type)


class WeightedGridMaker(object):
    """
    The WeightedGridMaker generates a cdms grid object (see cdms documentation for a description)
    and may also associate a WeightsMaker object with that grid.  The WeightedGridMaker object may be used by the
    VariableConditioner object to define a "target" grid to which the variable will be mapped.
    The WeightedGridMaker must be either provided with a cdms grid object or with information needed to generate a grid.
    """

    def __init__(self,
                 source=None,
                 var=None,
                 nlat=None, flat=None, dellat=None,
                 grid_type='uniform',
                 nlon=None, flon=None, dellon=None,
                 weightsMaker=None
                 ):
        """

        :param source: a cdms grid object or a file name (in which case the keyword "var" must be defined).
                Other keywords (except "var" and "WeightsMaker") will be ignored if "source" is a file name.
        :type source:

        :param var: the name of the variable that is needed from the file specified in the "source" argument
                (except when "source" refers directly to a grid object, in which case this argument is ignored).
        :type var: str

        :param nlat: the number of latitudes spanning the domain (which is ignored if "source" is a file name).
        :type nlat: float

        :param flat: the location of the first latitude (which is ignored if "source" is a file name or if "type" is
                'gaussian' or 'equal').
        :type flat: float

        :param dellat: the latitude spacing (which is ignored if "source" is a file name or if "type" is
                'gaussian' or 'equal').
        :type dellat: float

        :param grid_type: the type of grid that will be generated.  Options include: 'uniform' (equally spaced),
                'gaussian' (for use with spectral models), and 'equal' (for latitude spacing giving equal area grid
                cells as in the lmd5 model). This keyword will be ignored if "source" is a file name.
        :type grid_type: str

        :param nlon: the number of longitudes spanning the domain (which is ignored if "source" is a file name).
        :type nlon: float

        :param flon: the location of the first longitude (which by default is set to 0.0 but is ignored if "source"
                is a file name).
        :type flon: float

        :param dellon: the longitude spacing (which is ignored if the "source" is a file name).
        :type dellon: float

        :param weightsMaker: a :py:class:`WeightsMaker` object that should occupy the same grid as that returned by
                :py:class:`WeightedGridMaker`.
        :type weightsMaker: :py:class:`WeightsMaker`
        """
        self.longitude = GridAxis()
        self.latitude = GridAxis()
        self.longitude.n = nlon
        self.longitude.first = flon
        self.longitude.delta = dellon
        self.latitude.n = nlat
        self.latitude.first = flat
        self.latitude.delta = dellat
        self.latitude.type = grid_type
        if isinstance(source, cdms2.grid.AbstractGrid):
            self.grid = source
        elif isinstance(source, str):
            self.file = source
            f = cdms2.open(source)
            V = f[var]
            self.grid = V.getGrid()
        else:
            self.grid = None
            self.file = None
        if isinstance(weightsMaker, WeightsMaker):
            self.weightsMaker = weightsMaker
        elif weightsMaker is None:
            self.weightsMaker = WeightsMaker()
        else:
            raise WeightedGridMakerError(
                "WeightedGridMaker: weightsMaker must be None or WeightsMaker instance, you passed:" +
                repr(weightsMaker))
        self.variable = var

    def __str__(self):
        s = 'GridMaker Object:'
        if self.grid is not None:
            s += '\n' + str(self.grid)
        elif self.latitude.n is not None:
            s += '\nLongitude:\n' + str(self.longitude)
            s += '\nLatitude:\n' + str(self.latitude)
        elif self.file is not None:
            s += '\nFile:' + str(self.file) + '\n'
            s += 'Variable:' + str(self.variable)
        else:
            s += 'None'
        s += '\n' + str(self.weightsMaker)
        return s

    def get(self):
        value = self.grid
        if value is None:
            if self.latitude.n is not None:  # Ok we seem to have grid definition
                if self.latitude.type == 1:  # Gaussian
                    if self.longitude.first is None:
                        value = cdms2.createGaussianGrid(self.latitude.n)
                    else:
                        value = cdms2.createGaussianGrid(
                            self.latitude.n, self.longitude.first)
                elif self.latitude.type == 0:  # Uniform
                    value = cdms2.createUniformGrid(self.latitude.first,
                                                    self.latitude.n,
                                                    self.latitude.delta,
                                                    self.longitude.first,
                                                    self.longitude.n,
                                                    self.longitude.delta)
                elif self.latitude.type == 2:  # Equalarea
                    lat = cdms2.createEqualAreaAxis(self.latitude.n)
                    lon = cdms2.createUniformLongitude(self.longitude.first,
                                                       self.longitude.n,
                                                       self.longitude.delta)
                    value = cdms2.createGenericGrid(
                        lat[:], lon[:], lat.getBounds(), lon.getBounds())
            elif self.file is not None:
                f = cdms2.open(self.file)
                value = f[self.variable].getGrid()
                # Ok temporary stuff to try to be able to close the file
                lat = value.getLatitude()
                lon = value.getLongitude()
                value = cdms2.createRectGrid(lat, lon)
                f.close()
        return value

    __call__ = get

    __slots__ = [
        'longitude',
        'latitude',
        'weightsMaker',
        '_var',
        '_file',
        '_grid']

    def _get_var(self):
        return self._var

    def _set_var(self, value):
        self._var = ValidationFunctions.checkStringOrNone(self, 'var', value)
    variable = property(_get_var, _set_var)

    def _get_file(self):
        return self._file

    def _set_file(self, value):
        name, value = ValidationFunctions.setSlab(self, 'file', value)
        if name == 'file':
            self._file = value
        else:
            setattr(self, name, value)
    file = property(_get_file, _set_file)

    def _get_grid(self):
        return self._grid

    def _set_grid(self, value):
        self._grid = ValidationFunctions.setGrid(self, 'grid', value)
    grid = property(_get_grid, _set_grid)


class VariableConditionerError(WeightedGridMakerError):
    pass


class VariableConditioner(object):
    """The VariableConditioner constructor must be provided either with a transient variable or with information
        that will be used to define a masked variable.  Optional, additional information may be provided to indicate
        how the data should be mapped to a new grid, what masks should be applied, and how to scale and offset the data
        (to transform, for example, to alternative units). """

    def __init__(self, source, var=None, weightsMaker=None, weightedGridMaker=None, offset=0., slope=1.,
                 cdmsArguments=None, cdmsKeywords=None, id=None, preprocess=None, preprocessKeywords={}, comments=''):
        """
        :param source: a file name or a transient variable.  If an array is passed, a second associated array may also
                be passed (in which case source is a tuple), which contains the fraction of each grid cell
                for which the data value applies.  This fraction will be used if the variable is regridded.
        :type source:

        :param var: the name of the variable that is needed from the file specified in the "source" argument
                (except when "source" refers directly to a variable, in which case this argument is ignored).
        :type var: str

        :param cdmsArguments: a tuple or list of optional arguments used when retrieving a variable with cdms.
                For example, cdmsArguments=(cdutil.region.NH) specifies that data should be retrieved from the
                Northern Hemisphere only).  See the cdms documentation for more information.
        :type cdmsArguments: tuple

        :param cdmsKeywords: a dictionary defining "keyword:value" pairs used when retrieving a variable with cdms.
                For example, cdmsKeywords= {'latitude:(-90.0, 0.0)} specifies that data should be retrieved from the
                Southern Hemisphere only.  See the cdms documentation for more information.
        :type cdmsKeywords: dict

        :param weightsMaker: a WeightsMaker obj that should be applied to the masked variable (before any regridding).
        :type weightsMaker:

        :param weightedGridMaker: a WeightedGridMaker object that defines the target grid to which the data should be
                mapped.

                .. note::

                    If a WeightsMaker is associated with the WeightedGridMaker object, then that mask will be
                    applied to the data after regridding.
        :type weightedGridMaker: :py:class:`WeightsMaker`

        :param offset: used to change units of the variable by multiplying the data by "slope" and adding "offset"
                to the result.
        :type offset: float

        :param slope: used to change units of the variable by multiplying the data by "slope" and adding "offset"
                to the result.
        :type slope: float

        :param id: a string that can be used to identify your VariableConditioner object,
                but it is purely informational and not used otherwise.
        :type id: str
        """
        self.id = id
        self.variable = var
        self.offset = offset
        self.slope = slope
        if cdmsArguments is None:
            self.cdmsArguments = []
        else:
            self.cdmsArguments = cdmsArguments
        if cdmsKeywords is None:
            self.cdmsKeywords = {}
        else:
            self.cdmsKeywords = cdmsKeywords
        if weightsMaker is None:
            self.weightsMaker = WeightsMaker()
        elif isinstance(weightsMaker, WeightsMaker) or weightsMaker is None:
            self.weightsMaker = weightsMaker
        else:
            raise VariableConditionerError("WeightsMaker is wrong")
        if weightedGridMaker is None:
            self.weightedGridMaker = WeightedGridMaker()
        elif isinstance(weightedGridMaker, WeightedGridMaker):
            self.weightedGridMaker = weightedGridMaker
        elif isinstance(weightedGridMaker, cdms2.grid.AbstractGrid):
            self.weightedGridMaker = WeightedGridMaker()
            self.weightedGridMaker.grid = weightedGridMaker

        if isinstance(source, bytes):
            self.file = source
            self.data = None
        else:
            self.data = source
            self.file = None
        self.preprocess = preprocess
        self.preprocessKeywords = preprocessKeywords
        self.comments = comments

    def __str__(self):
        s = 'VariableConditioner Object\n'
        s += 'id:' + str(self.id)
        if self.file is not None:
            s += '\nfile:' + str(self.file)
            s += '\nvar:' + str(self.variable)
        else:
            s += '\ndata:' + str(self.data)
        if self.cdmsArguments is not None:
            s += '\ncdmsArguments:'
            for a in self.cdmsArguments:
                s += str(a) + ', '
        if self.cdmsKeywords is not None:
            s += '\ncdmsKeywords:'
            for k in list(self.cdmsKeywords.keys()):
                s += '\n\t' + k + ':' + str(self.cdmsKeywords[k])
        s += '\n' + str(self.weightsMaker)
        s += '\n' + str(self.weightedGridMaker)
        if self.slope != 1.:
            s += '\nslope:' + str(self.slope)
        if self.offset != 0.:
            s += '\noffset:' + str(self.offset)
        if self.comments != '':
            s += '\ncomments:' + str(self.comments)
        return s

    def get(self, returnTuple=1):
        value = self.data
        frc = None
        if type(value) in [tuple, list]:
            value, frc = value
        if isinstance(value, numpy.ndarray) or numpy.ma.isMA(
                value):  # Variable defined from array
            if frc is None:
                frc = numpy.ma.ones(value.shape, dtype=numpy.float32)
            kw = {}
            args = []
            # Add user defined cdmsArguments
            for a in self.cdmsArguments:
                args.append(a)
            # Add user defined cdmsKeywords
            for k in list(self.cdmsKeywords.keys()):
                kw[k] = self.cdmsKeywords[k]
            # try to apply, if not forget about it
            try:
                v = value(*args, **kw)
                frc = frc(*args, **kw)
                # Now removes the slice types
                # because they can't be used twice
                for k in list(kw.keys()):
                    if isinstance(kw[k], slice):
                        del(kw[k])
                for i in range(len(args)):
                    if isinstance(args[i], slice):
                        args.pop(i)
                        i = i - 1
            except BaseException:
                v = value
        else:  # Variable comes from a file, need to be retrieved
            f = cdms2.open(self.file)
            kw = {}
            args = []
            # Add user defined cdmsArguments
            for a in self.cdmsArguments:
                args.append(a)
            # Add user defined cdmsKeywords
            for k in list(self.cdmsKeywords.keys()):
                kw[k] = self.cdmsKeywords[k]
            v = f(self.variable, *args, **kw)
            f.close()
            # Now removes the slice types
            # because they can't be used twice
            for k in list(kw.keys()):
                if isinstance(kw[k], slice):
                    del(kw[k])
            for i in range(len(args)):
                if isinstance(args[i], slice):
                    args.pop(i)
                    i = i - 1

        # At that stage applied the preprocess function
        if self.preprocess is not None:
            v = self.preprocess(*(v,), **self.preprocessKeywords)

        # Create the fractions
        if frc is None:
            frc = v.mask
            if frc is numpy.ma.nomask:  # no mask
                # Create a bunch of ones (100%)
                frc = numpy.ones(v.shape, numpy.float32)
            else:
                # Fraction are actually just the opposite of the mask at that
                # stage !
                # Sometimes if it is bytes it doesn't work
                frc = frc.astype(MV2.float32)
                frc = 1. - frc
                # no need for double precision here !
                frc = frc.astype(MV2.float32)
        else:
            m = v.mask
            if m is not numpy.ma.nomask:
                frc = MV2.where(m, 0., frc).filled(0.)
        # Now get the associted weights object
        # Note that we pass v in case some of the values are defined as "input"
        # in which case it would use v instead of the weights for weightsing
        m = self.weightsMaker(v)
        if m is not None:
            # grows the variable and the weights for possible Xtra dimensions
            m = m(*args, **kw)
            v, m = genutil.grower(v, m)
            # make sure variable and weights are compatible
            if m.shape != v.shape:
                raise VariableConditionerError(
                    'weights and variable have different shapes:' +
                    'weights is {} and grid is {}'.format(m.shape, v.shape))
            # make sure they're on the same grid (in case one starts at 0 and
            # one at -180 for example

            if m.getGrid() is not v.getGrid():
                m = m.astype("i").regrid(v.getGrid())

            # Mask the dataset where the fraction are 0.
            v = MV2.masked_where(MV2.equal(m.filled(0), 0.), v)
            # Update the fractions
            frc = m.filled(0.)
            m = v.mask
            if m is not numpy.ma.nomask:
                frc = numpy.where(m, 0., frc)
                # Fill the mask with ones, i.e. set fraction to 0 when the mask is masked
                # frc = numpy.where(m.filled(1),0.,frc)
        # Now get the target grid
        g = self.weightedGridMaker()
        if g is not None:  # we do have a target grid to go to !
            # Create the regridder object
            rf = regrid2.Horizontal(v.getGrid(), g)
            # and regrid passing the weights to use to each grid cell
            # at this point it should be only 0/1
            v, frc = rf(v, mask=1. - frc, returnTuple=1)
            frc = MV2.array(frc)
            frc.setAxisList(v.getAxisList())
            v = v(*args, **kw)
            frc = frc(*args, **kw).filled(0.)
            # Note that now frc is not necessarily 0. and 1. but actuall fraction
            # of the grid cell that has real data in it.
            # do we weights after this regridding ?
            # once again pass v in case the weightsing wants
            # to work on the variable
            m = self.weightedGridMaker.weightsMaker(v)
            if m is not None:  # we have a weights
                m = m(*args, **kw)  # apply the extra cdmsKeywords to it
                v, m = genutil.grower(v, m)
                # make sure variable and weights are compatible
                if m.shape != v.shape:
                    raise VariableConditionerError(
                        'weights and variable have different shapes:' +
                        'weights is {} and grid is {}'.format(m.shape, v.shape))
                # make sure they're on the same grid (in case one starts at 0
                # and one at -180 for example

                if m.getGrid() is not v.getGrid():
                    m = m.astype("i").regrid(v.getGrid())

                v = MV2.masked_where(MV2.equal(m.filled(0.), 0.), v)
                # weights the fraction where needed
                frc = m.filled(0.)
                m = v.mask
                if m is not numpy.ma.nomask:
                    frc = numpy.where(m, 0., frc)
# frc=numpy.where(m.filled(1),0.,frc)
        # Now make the fraction an MV2 and puts the dim from v on it
        frc = MV2.array(frc)
        frc.setAxisList(v.getAxisList())
        # just in case applies the cdmsKeywords again
        # usefull in case your final grid is global
        # and you specified Nino3 region for example.
        v = v(*args, **kw)
        frc = frc(*args, **kw) .filled(0.)
        if v.missing_value is None:
            v.missing_value = 1.e20
        v = MV2.masked_where(MV2.equal(frc, 0.), v)
        # Now applies the slope and offset if necessary
        if self.slope != 1.:
            v = v * self.slope
        if self.offset != 0.:
            v = v + self.offset

        if not ((v.mask is None) or (v.mask is MV2.nomask)):
            if numpy.ma.allclose(v.mask, 0.):
                v._mask = numpy.ma.nomask
        # Returns the variable and the fractions or just the variable
        if returnTuple:
            # if not ((frc.mask is None) or (frc.mask is MV2.nomask)):
            # if numpy.ma.allclose(frc.mask,0.):
            # frc._mask=None
            return v, frc
        else:
            return v

    # makes get the default function
    __call__ = get

    __slots__ = [
        'source',
        'weightsMaker',
        'cdmsArguments',
        'cdmsKeywords',
        'preprocessKeywords',
        'preprocess',
        'comments',
        '_var',
        '_id',
        '_slope',
        '_offset',
        '_file',
        '_data',
        '_weightedGridMaker']

    def _get_var(self):
        return self._var

    def _set_var(self, value):
        self._var = ValidationFunctions.checkStringOrNone(self, 'var', value)
    variable = property(_get_var, _set_var)

    def _get_id(self):
        return self._id

    def _set_id(self, value):
        self._id = ValidationFunctions.checkStringOrNone(self, 'id', value)
    id = property(_get_id, _set_id)

    def _get_slope(self):
        return self._slope

    def _set_slope(self, value):
        self._slope = ValidationFunctions.checkNumber(self, 'slope', value)
    slope = property(_get_slope, _set_slope)

    def _get_offset(self):
        return self._offset

    def _set_offset(self, value):
        self._offset = ValidationFunctions.checkNumber(self, 'offset', value)
    offset = property(_get_offset, _set_offset)

    def _get_file(self):
        return self._file

    def _set_file(self, value):
        name, value = ValidationFunctions.setSlab(self, 'file', value)
        if name == 'file':
            self._file = value
        else:
            setattr(self, name, value)
    file = property(_get_file, _set_file)

    def _get_data(self):
        return self._data

    def _set_data(self, value):
        self._data = ValidationFunctions.setSlabOnly(self, 'data', value)
    data = property(_get_data, _set_data)

    def _get_weightedGridMaker(self):
        return self._weightedGridMaker

    def _set_weightedGridMaker(self, value):
        self._weightedGridMaker = ValidationFunctions.setDataSetGrid(
            self, 'weightedGridMaker', value)
    weightedGridMaker = property(
        _get_weightedGridMaker,
        _set_weightedGridMaker)


class VariablesMatcherError(VariableConditionerError):
    pass


class VariablesMatcher(object):
    """
    The VariablesMatcher is defined to facilitate comparisons of two different variables by preprocessing them and
    ensuring that they are expressed in the same units and are placed on a common grid.
    Preprocessing includes selection of the spatial domain and time-period and provides for various masking and
    regridding options.

    The VariablesMatcher relies on three different kinds of supporting objects: the VariableConditioner,
    the WeightedGridMaker, and the WeightsMaker.  The VariableConditioner can modify a field in various ways
    (e.g., applying masks, mapping it to a new grid, applying scale factors and adding a constant to it, which is useful
    in transforming the units).  The WeightsMaker defines a mask, and the WeightedGridMaker defines a grid
    (and possibly associates a WeightsMaker object with it).  The WeightsMaker object will be described first, because
    it may be needed by the other two.  The WeightedGridMaker will be described next because it may be needed by the
    VariableConditioner.
    """

    def __init__(self, variableConditioner1=None, variableConditioner2=None,
                 externalVariableConditioner=None, weightedGridMaker=None, cdmsArguments=[], cdmsKeywords={}):
        """
        :param variableConditioner1: a VariableConditioner object or a file name or a transient variable
                (from which a VariableConditioner will be constructed). It may also be a tuple comprising a transient
                variable plus a fraction associated with each cell (which will be used in constructing "weights").
                If variableConditioner1 is a file name, then the user must also define the name of the variable
                (e.g., VM.variableConditioner1.var='tas').
        :type :py:class:`VariableConditioner` or str or transient variable

        :param variableConditioner2: as variableConditioner1, except if variable 2 is not on the same grid as variable 1
                after all processing is completed, then variable 2 will be mapped to variable 1's grid.
        :type variableConditioner2: :py:class:`VariableConditioner`

        :param externalVariableConditioner: optional argument used to mask both variable 1 and variable 2 with its own
                mask. Variable 1 and variable 2 are mapped to the external variable grid before applying the mask.
                The external variable weights are applied (except where the weights associated with the variables are
                zero) The externalVariableConditioner is generally not needed unless an external time-varying mask is
                to be applied.
        :type externalVariableConditioner: :py:class:`VariableConditioner`

        :param weightedGridMaker: an optional :py:class:`WeightedGridMaker` object that defines the target grid to which
                variable 1 and variable 2 should be mapped as a last step.

                .. note::

                    If a :py:class:`WeightsMaker` is associated with the :py:class:`WeightedGridMaker` object,
                    then the mask will be applied to the data after regridding.
        :type weightedGridMaker: :py:class:`WeightedGridMaker`

        :param cdmsArguments: a tuple of optional arguments used when retrieving a variable with cdms. (For example,
                cdmsArguments=(cdutil.region.NH) specifies that data should be retrieved from the Northern Hemisphere
                only).  See the cdms documentation for more information.  The cdmsArguments set here will replace all
                arguments that might be set for individual VariableConditioner objects (i.e., "1", "2" and "external").
        :type cdmsArguments: tuple

        :param cdmsKeywords: a dictionary defining "keyword:value" pairs used when retrieving a variable with cdms.
                For example, cdmsKeywords= {'latitude:(-90.0, 0.0)} specifies that data should be retrieved from the
                Southern Hemisphere only.  See the cdms documentation for more information.
                The cdmsKeywords set here will be appended to or take the place of those that might be set for
                individual VariableConditioner objects (i.e., "1", "2" and "external").
        :type cdmsKeywords: dict
        """
        # First VariableConditioner
        if isinstance(variableConditioner1, VariableConditioner):
            self.variableConditioner1 = variableConditioner1
        else:
            self.variableConditioner1 = VariableConditioner(
                variableConditioner1)
        # Second VariableConditioner
        if isinstance(variableConditioner2, VariableConditioner):
            self.variableConditioner2 = variableConditioner2
        else:
            self.variableConditioner2 = VariableConditioner(
                variableConditioner2)
        # External VariableConditioner
        if isinstance(externalVariableConditioner, VariableConditioner):
            self.externalVariableConditioner = externalVariableConditioner
        elif externalVariableConditioner is None:
            self.externalVariableConditioner = None
        else:
            self.externalVariableConditioner = VariableConditioner(
                externalVariableConditioner)
        # Final Grid
        if weightedGridMaker is None:
            self.weightedGridMaker = WeightedGridMaker()
        elif isinstance(weightedGridMaker, WeightedGridMaker):
            self.weightedGridMaker = weightedGridMaker
        elif isinstance(weightedGridMaker, cdms2.grid.AbstractGrid):
            self.weightedGridMaker = weightedGridMaker()
            self.weightedGridMaker.grid = weightedGridMaker

        self.cdmsArguments = cdmsArguments
        self.cdmsKeywords = cdmsKeywords

        # aliases to make my life MUCH easier !
        self.V1 = self.variableConditioner1
        self.V2 = self.variableConditioner2
        self.EV = self.externalVariableConditioner

    def __str__(self):
        s = 'VariablesMatcher Object:\n'
        s += '---------\nVariableConditioner 1\n---------\n' + str(self.V1)
        s += '\n---------\nVariableConditioner 2\n---------\n' + str(self.V2)
        s += '\n----------------\nExternal VariableConditioner\n----------------\n' + \
            str(self.EV)
        s += '\n----------\nFinal Grid\n----------\n' + \
            str(self.weightedGridMaker)
        return s

    def get(self, returnTuple=1):
        # Ok now the tough part try to figure out everything for the user...

        # overwrite the defintion for the variableConditioners cdmsArguments
        if self.cdmsArguments != []:
            setattr(self.V1, 'cdmsArguments', self.cdmsArguments)
            setattr(self.V2, 'cdmsArguments', self.cdmsArguments)
            if self.EV is not None:
                setattr(self.EV, 'cdmsArguments', self.cdmsArguments)

        # overwrite the defintion for the variableConditioners cdmsKeyowrds
        for k in list(self.cdmsKeywords.keys()):
            self.V1.cdmsKeywords[k] = self.cdmsKeywords[k]
            self.V2.cdmsKeywords[k] = self.cdmsKeywords[k]
            if self.EV is not None:
                self.EV.cdmsKeywords[k] = self.cdmsKeywords[k]

        # Checks the time:
        # 2003-9-15: Added options if both var don't have time then still works
        d1 = None
        d2 = None
        frc1 = None
        frc2 = None
        autotime = None

        if 'time' not in self.V1.cdmsKeywords:
            if 'time' in self.V2.cdmsKeywords:
                d2 = self.V2(returnTuple=returnTuple)
                if returnTuple:
                    t = d2[0].getTime().asComponentTime()
                else:
                    t = d2.getTime().asComponentTime()
                self.V1.cdmsKeywords['time'] = (t[0], t[-1])
                d1 = self.V1(returnTuple=returnTuple)
                del(self.V1.cdmsKeywords['time'])
            else:  # Automatically gets the maximum common time
                d2 = self.V2(returnTuple=returnTuple)
                if returnTuple:
                    t = d2[0].getTime()
                    if t is not None:
                        t = t.asComponentTime()
                else:
                    t = d2.getTime()
                    if t is not None:
                        t = t.asComponentTime()
                if t is not None:
                    self.V1.cdmsKeywords['time'] = (t[0], t[-1])
                d1 = self.V1(returnTuple=returnTuple)
                if returnTuple:
                    t1 = d1[0].getTime()
                    if t1 is not None:
                        t1 = t1.asComponentTime()
                else:
                    t1 = d1.getTime()
                    if t1 is not None:
                        t1 = t1.asComponentTime()
                if t1 is not None:
                    autotime = [t1[0], t1[-1], 'ccb']
                    if cdtime.compare(t1[0], t[0]) == -1:
                        autotime[0] = t[0]
                    if cdtime.compare(t1[-1], t[-1]) == 1:
                        autotime[1] = t[-1]
                    self.V1.cdmsKeywords['time'] = autotime
                d1 = self.V1(returnTuple=returnTuple)
                if t1 is not None:
                    del(self.V1.cdmsKeywords['time'])
                    self.V2.cdmsKeywords['time'] = autotime
                    d2 = self.V2(returnTuple=returnTuple)
                    del(self.V2.cdmsKeywords['time'])
        elif 'time' not in self.V2.cdmsKeywords:
            d1 = self.V1(returnTuple=returnTuple)
            if returnTuple:
                t = d1[0].getTime().asComponentTime()
            else:
                t = d1.getTime().asComponentTime()
            if t is not None:
                self.V2.cdmsKeywords['time'] = (t[0], t[-1])
            d2 = self.V2(returnTuple=returnTuple)
            if t is not None:
                del(self.V2.cdmsKeywords['time'])

        # Now get the variableConditioners 1 and 2 if necessary
        if d1 is None:
            d1 = self.V1(returnTuple=returnTuple)
        if d2 is None:
            d2 = self.V2(returnTuple=returnTuple)

        if returnTuple:
            # break the output if necessary
            frc2 = d2[1]
            d2 = d2[0]
            frc1 = d1[1]
            d1 = d1[0]
            frc1 = MV2.array(frc1)
            frc2 = MV2.array(frc2)
        else:
            frc1 = MV2.ones(d1.shape, typecode=MV2.float32)
            frc2 = MV2.ones(d2.shape, typecode=MV2.float32)

        frc1.setAxisList(d1.getAxisList())
        frc2.setAxisList(d2.getAxisList())

        if d1.shape != d2.shape:
            if d1.ndim > d2.ndim:
                d1, d2 = genutil.grower(d1, d2, singleton=1)
                frc1, frc2 = genutil.grower(frc1, frc2, singleton=1)
            else:
                d2, d1 = genutil.grower(d2, d1, singleton=1)
                frc2, frc1 = genutil.grower(frc2, frc1, singleton=1)

        # External variableConditioner ?
        if self.EV is not None:
            ed = None
            if 'time' not in self.EV.cdmsKeywords:
                t = d1.getTime().asComponentTime()
                if t is not None:
                    self.EV.cdmsKeywords['time'] = (t[0], t[-1])
                ed = self.EV(returnTuple=1)
                frced = ed[1]
                ed = ed[0]
                frced = MV2.array(frced)
                frced.setAxisList(ed.getAxisList())

            if ed is None:
                ed = self.EV(returnTuple=1)
                frced = ed[1]
                ed = ed[0]
                frced = MV2.array(frced)
                frced.setAxisList(ed.getAxisList())
            g = ed.getGrid()
            g1 = d1.getGrid()
            rf = regrid2.Horizontal(g1, g)
            d1, frc1 = rf(d1, mask=1. - frc1.filled(0.), returnTuple=1)
            g2 = d2.getGrid()
            rf = regrid2.Horizontal(g2, g)
            d2, frc2 = rf(d2, mask=1. - frc2.filled(0.), returnTuple=1)
            frc1 = MV2.array(frc1)
            frc1.setAxisList(d1.getAxisList())
            frc2 = MV2.array(frc2)
            frc2.setAxisList(d2.getAxisList())
            d1, ed = genutil.grower(d1, ed, singleton=1)
            d2, ed = genutil.grower(d2, ed, singleton=1)
            ed, frced = genutil.grower(ed, frced, singleton=1)

            frc1 = numpy.ma.where(
                numpy.ma.equal(
                    frc1.filled(0.),
                    0.),
                0.,
                frced.filled(0.))
            frc2 = numpy.ma.where(
                numpy.ma.equal(
                    frc2.filled(0.),
                    0.),
                0.,
                frced.filled(0.))

            d1 = MV2.masked_where(MV2.equal(frc1.filled(0.), 0.), d1)
            d2 = MV2.masked_where(MV2.equal(frc2.filled(0.), 0.), d2)

        # Final grid ?
        g = self.weightedGridMaker()
        if g is not None:
            g1 = d1.getGrid()
            g2 = d2.getGrid()
            rf1 = regrid2.Horizontal(g1, g)
            rf2 = regrid2.Horizontal(g2, g)
            d1, frc1 = rf1(d1, mask=1. - frc1.filled(0.), returnTuple=1)
# m=1.-frc2.filled(0.)
            d2, frc2 = rf2(d2, mask=1. - frc2.filled(0.), returnTuple=1)
            frc1 = MV2.array(frc1)
            frc1.setAxisList(d1.getAxisList())
            frc2 = MV2.array(frc2)
            frc2.setAxisList(d2.getAxisList())
            m = self.weightedGridMaker.weightsMaker(d1)
            if m is not None:
                d1, m = genutil.grower(d1, m)
                frc1, m = genutil.grower(frc1, m)
                frc1 = m.filled(0.)
                d1 = MV2.masked_where(MV2.equal(frc1, 0.), d1)
                m = d1.mask
                if m is not None:
                    frc1 = numpy.where(m, 0., frc1)
            m = self.weightedGridMaker.weightsMaker(d2)
            if m is not None:
                d2, m = genutil.grower(d2, m)
                frc2, m = genutil.grower(frc2, m)
                frc2 = m.filled(0.)
                d2 = MV2.masked_where(MV2.equal(frc2, 0.), d2)
                m = d2.mask
                if m is not numpy.ma.nomask:
                    frc2 = numpy.where(m, 0., frc2)
        elif d1.getGrid() != d2.getGrid():
            g1 = d1.getGrid()
            g2 = d2.getGrid()
            rf = regrid2.Horizontal(g2, g1)
            d2, frc2 = rf(d2, mask=1. - frc2.filled(0.), returnTuple=1)
        frc1 = MV2.array(frc1)
        frc1.setAxisList(d1.getAxisList())
        frc2 = MV2.array(frc2)
        frc2.setAxisList(d2.getAxisList())

        # CdmsArguments or CdmsKeywords
        if self.cdmsArguments is not None:
            d1 = d1(*self.cdmsArguments)
            d2 = d2(*self.cdmsArguments)
            frc1 = frc1(*self.cdmsArguments)
            frc2 = frc2(*self.cdmsArguments)

        if self.cdmsKeywords is not None:
            d1 = d1(**self.cdmsKeywords)
            d2 = d2(**self.cdmsKeywords)
            frc1 = frc1(**self.cdmsKeywords)
            frc2 = frc2(**self.cdmsKeywords)

        d1 = MV2.masked_where(MV2.equal(frc1, 0.), d1)
        d2 = MV2.masked_where(MV2.equal(frc2, 0.), d2)
        if not ((d1.mask is None) or (d1.mask is MV2.nomask)):
            if numpy.ma.allclose(d1.mask, 0.):
                d1._mask = numpy.ma.nomask
        if not ((d2.mask is None) or (d2.mask is MV2.nomask)):
            if numpy.ma.allclose(d2.mask, 0.):
                d2._mask = numpy.ma.nomask
        if returnTuple:
            if not ((frc1.mask is None) or (frc1.mask is MV2.nomask)):
                if numpy.ma.allclose(frc1.mask, 0.):
                    frc1._mask = numpy.ma.nomask
            if not ((frc2.mask is None) or (frc2.mask is MV2.nomask)):
                if numpy.ma.allclose(frc2.mask, 0.):
                    frc2._mask = numpy.ma.nomask
            return (d1, frc1), (d2, frc2)
        else:
            return d1, d2

    __call__ = get
